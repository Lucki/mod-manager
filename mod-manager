#!/usr/bin/env python

from enum import Enum
from pathlib import Path
import subprocess
import sys
from time import sleep
import tomlkit
from xdg import BaseDirectory
import os
import argparse

program_name = "mod-manager"
xdg_config = BaseDirectory.save_config_path(program_name)


class Game():
    class State(Enum):
        INVALID = -1
        NORMAL = 0
        MOUNTED = 1
        MOVED = 2

    def __init__(self, game_id, game_set=None, ignore_overlays=False) -> None:
        self.__id = game_id

        self.xdg_cache = BaseDirectory.save_cache_path(
            os.path.join(program_name, self.__id)
        )

        self.__xdg_runtime = os.path.join(
            BaseDirectory.get_runtime_dir(), program_name, self.__id)

        self.__config_file = os.path.join(xdg_config, f"{self.__id}.toml")
        assert(os.path.exists(self.__config_file))

        with open(self.__config_file, "r") as f:
            self.__config = tomlkit.parse(f.read())
        assert(self.__config["path"])

        self.__path = self.__config["path"]
        self.__moved_path = f"{self.__config['path']}_{program_name}"

        self.__state = self.__current_state()
        assert not (self.__state is Game.State.INVALID)

        if "mod_root_path" in self.__config:
            self.mod_root_path = self.__config['mod_root_path']
        else:
            self.mod_root_path = BaseDirectory.save_data_path(
                os.path.join(program_name, self.__id)
            )

        self.__writable = False
        if "writable" in self.__config:
            self.__writable = self.__config["writable"]

        self.run_pre_commands = False
        if "run_pre_command" in self.__config:
            self.run_pre_commands = self.__config["run_pre_command"]

        self.__pre_runs = []

        if ignore_overlays:
            self.__mount_options = f"x-gvfs-hide,comment=x-gvfs-hide,lowerdir={self.__moved_path}"
        else:
            if game_set is not None:
                self.__config["active"] = game_set

                # Overwrite?
                # with open(self.__config_file, "w") as f:
                #     f.write(tomlkit.dumps(self.__config))
            else:
                assert("active" in self.__config)

            assert(self.__config["active"] in self.__config)

            self.__mount_options = self.__append_overlays(
                self.__config[self.__config["active"]])

            self.__mount_options = f"x-gvfs-hide,comment=x-gvfs-hide,lowerdir={self.__mount_options}:{self.__moved_path}"

        self.__cwd = Path.cwd()
        if self.__cwd.is_relative_to(self.__path):
            self.__change_cwd = True

    def __current_state(self):
        if not os.path.exists(self.__path):
            if not os.path.exists(self.__moved_path):
                return Game.State.INVALID

            if not os.listdir(self.__moved_path):
                return Game.State.INVALID

            return Game.State.MOVED

        if os.path.ismount(self.__path):
            if not os.path.exists(self.__moved_path):
                return Game.State.INVALID

            if not os.listdir(self.__moved_path):
                return Game.State.INVALID

            return Game.State.MOUNTED

        if not os.listdir(self.__path):
            if not os.path.exists(self.__moved_path):
                return Game.State.INVALID

            if not os.listdir(self.__moved_path):
                return Game.State.INVALID

            # Path exists but is empty and not mounted, clean that up
            os.rmdir(self.__path)
            return Game.State.MOVED

        # Not mounted and both folders not empty
        if os.path.exists(self.__moved_path) and os.listdir(self.__moved_path):
            return Game.State.INVALID

        return Game.State.NORMAL

    def activate(self, writable=False, persistent_name=None):
        self.__state = self.__current_state()
        assert (self.__state is not Game.State.INVALID)

        # Re-Mount in case the set has changed in the config
        if self.__state is Game.State.MOUNTED:
            self.deactivate()

        if self.__state is Game.State.NORMAL:
            os.rename(self.__path, self.__moved_path)
            self.__state = self.__current_state()

        assert (self.__state is Game.State.MOVED)
        os.mkdir(self.__path)

        if writable or self.__writable:
            if persistent_name is None:
                persistent_name = f"{self.__config['active']}_persistent"

            upperdir = os.path.join(self.xdg_cache, persistent_name)
            workdir = os.path.join(self.xdg_cache, "workdir")
            indexdir = os.path.join(workdir, "index")
            work = os.path.join(workdir, "work")

            if not os.path.exists(upperdir):
                os.mkdir(upperdir)

            if not os.path.exists(workdir):
                os.mkdir(workdir)

            # For safety the helper script will fail if one of the two doesn't exist
            # Create the missing one
            if not os.path.exists(indexdir) or not os.path.exists(work):
                if not os.path.exists(indexdir):
                    os.mkdir(indexdir)
                if not os.path.exists(work):
                    os.mkdir(work)

            subprocess.run(
                ["pkexec",
                    "mod-manager-overlayfs-helper",
                    "cleanworkdir",
                    workdir],
                check=True
            )

            self.__mount_options = f"{self.__mount_options},upperdir={upperdir},workdir={workdir}"

        # Make sure we're not blocking ourself by cwd == mount point
        if self.__change_cwd:
            # FIXME: change to Path.absolute() with python 3.11
            os.chdir(Path.home().resolve())

        subprocess.run(
            ["pkexec",
             "mod-manager-overlayfs-helper",
             "mount",
             self.__id,
             self.__mount_options,
             self.__path],
            check=True
        )

        if self.__change_cwd:
            # FIXME: change to Path.absolute() with python 3.11
            os.chdir(self.__cwd.resolve())

        if not os.path.ismount():
            # Emergency exit
            print("Mounting somehow failed?", file=sys.stderr)
            sys.exit(1)

        self.__run_pre_commands()

    def deactivate(self):
        # Stop pids that were started continuously
        if os.path.exists(self.__xdg_runtime):
            pids = os.listdir(self.__xdg_runtime)

            for pid in pids:
                os.kill(pid)

        self.__state = self.__current_state()
        assert (self.__state is not Game.State.INVALID)

        if self.__state is Game.State.NORMAL:
            return

        if self.__state is Game.State.MOUNTED:
            # Make sure we're not blocking ourself by cwd == mount point
            if self.__change_cwd:
                # FIXME: change to Path.absolute() with python 3.11
                os.chdir(Path.home().resolve())

            subprocess.run(
                ["pkexec",
                 "mod-manager-overlayfs-helper",
                 "umount",
                 self.__id],
                check=True
            )

            if self.__change_cwd:
                # FIXME: change to Path.absolute() with python 3.11
                os.chdir(self.__cwd.resolve())

            # Wait some time to allow the file system to finalize
            sleep(2)

        os.rmdir(self.__path)
        os.rename(self.__moved_path, self.__path)
        self.__state = self.__current_state()

    def __append_overlays(self, set, options_string=""):
        if "writable" in set:
            self.__writable = set["writable"] or self.__writable

        if "run_pre_command" in set:
            self.run_pre_commands = set["run_pre_command"] or self.run_pre_commands

        assert("mods" in set)

        for overlay in set["mods"]:
            if overlay in self.__config:
                options_string = self.__append_overlays(self.__config[overlay],
                                                        options_string)
                continue

            overlay_path = os.path.join(self.mod_root_path, overlay)
            assert(os.path.exists(overlay_path))

            # Don't allow duplicates
            if overlay_path in options_string:
                continue

            options_string = f"{options_string}:{overlay_path}"

        if options_string[0] == ':':
            return options_string[1:len(options_string)]

        return options_string

    def __run_pre_commands(self):
        assert("pre_command" in self.__config)

        for pre_command in self.__config["pre_command"]:
            assert("command" in pre_command)

            wait = True
            delay = None

            if "wait_for_exit" in pre_command:
                wait = pre_command["wait_for_exit"]

            if "delay" in pre_command:
                delay = pre_command["delay"]

            env = os.environ.copy()
            if "environment" in pre_command:
                for variable in pre_command["environment"]:
                    env[variable] = pre_command["environment"][variable]

            if wait:
                subprocess.run(
                    pre_command["command"],
                    env=env,
                    check=True
                )
            else:
                self.__pre_runs.append(
                    subprocess.Popen(
                        pre_command["command"],
                        env=env
                    ))

            if delay is not None:
                sleep(delay)

        os.makedirs(self.__xdg_runtime, exist_ok=True)
        for process in self.__pre_runs:
            # create pid file
            open(os.path.join(self.__xdg_runtime, process.pid), 'a').close()


argparser = argparse.ArgumentParser(
    description="Simple game mod manager using OverlayFS"
)

subparser = argparser.add_subparsers(help="Possible actions", dest='action')

game_subparser = argparse.ArgumentParser(add_help=False)
game_subparser.add_argument('game',
                            help="ID that matches the configuration file, if None all config files will be affected",
                            nargs='?',
                            default=None
                            )

game_required_subparser = argparse.ArgumentParser(add_help=False)
game_required_subparser.add_argument('game',
                                     help="ID that matches the configuration file, if None all config files will be affected",
                                     default=None
                                     )

set_subparser = argparse.ArgumentParser(add_help=False)
set_subparser.add_argument('--set',
                           help="The mod set to activate, overwrites the activated set in the config file",
                           nargs='?',
                           )

writable_subparser = argparse.ArgumentParser(add_help=False)
writable_subparser.add_argument('--writable',
                                action='store_true',
                                help="Ensure the merged directories are writable. Written changes can be found in the cache folder.")

parser_activate = subparser.add_parser("activate",
                                       parents=[
                                           game_subparser, set_subparser, writable_subparser],
                                       help="Activate a mod by mounting the OverlayFS inplace")

parser_deactivate = subparser.add_parser("deactivate",
                                         parents=[game_subparser],
                                         help="Deactivate an already activated mod by unmounting the OverlayFS")

parser_wrap = subparser.add_parser("wrap",
                                   parents=[game_required_subparser,
                                            set_subparser, writable_subparser],
                                   help="Wrap an external command in between an activation and deactivation")
parser_wrap.add_argument('external_command',
                         help="Command to wrap around to. Placed last after POSIX style ' -- '",
                         nargs=argparse.REMAINDER)

parser_add = subparser.add_parser("setup",
                                  parents=[game_required_subparser],
                                  help="Setup and collect changes for a new mod by making changes to the game")
parser_add.add_argument('mod',
                        help="The name of the new mod"
                        )

args = argparser.parse_args()

if args.game is not None:
    games = [f"{args.game}.toml"]
else:
    games = os.listdir(xdg_config)

if len(games) > 1 and args.action != "activate" and args.action != "deactivate":
    sys.exit(1)

if len(games) > 1 and args.action == "activate" and args.set:
    sys.exit(1)

if args.action == "setup" and args.mod is None:
    print("Needs a mod name for adding", file=sys.stderr)
    sys.exit(1)

for game_config_path in games:
    if not game_config_path.endswith(".toml"):
        continue

    game_id = game_config_path[:-5]
    # print(game_id)

    if args.action == "activate" or args.action == "wrap":
        game = Game(game_id, args.set)
    elif args.action == "setup":
        game = Game(game_id, ignore_overlays=True)
    else:
        game = Game(game_id)

    if args.action == "deactivate":
        game.deactivate()
        continue

    if args.action == "activate":
        game.activate(writable=args.writable)
        continue

    if args.action == "wrap":
        game.activate(writable=args.writable)

        try:
            subprocess.call(args.external_command)
        finally:
            # Wait some time to allow programs to finalize
            sleep(2)
            game.deactivate()
        continue

    if args.action == "setup":
        # Check if new path already exists
        new_mod_path = os.path.join(game.mod_root_path, args.mod)
        if os.path.exists(new_mod_path):
            print("Mod already exists, aborting.", file=sys.stderr)
            continue

        game.activate(writable=True,
                      persistent_name="persistent_setup")

        input(
            f"Make the required changes to the main folder.\nPress Enter when done setting up - you'll find the changes in '{new_mod_path}' afterwards.")

        game.deactivate()

        persistent_dir = os.path.join(game.xdg_cache, "persistent_setup")
        os.makedirs(game.mod_root_path, exist_ok=True)
        os.rename(persistent_dir, new_mod_path)

        continue
